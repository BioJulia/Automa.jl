<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parsing IOs · Automa.jl</title><meta name="title" content="Parsing IOs · Automa.jl"/><meta property="og:title" content="Parsing IOs · Automa.jl"/><meta property="twitter:title" content="Parsing IOs · Automa.jl"/><meta name="description" content="Documentation for Automa.jl."/><meta property="og:description" content="Documentation for Automa.jl."/><meta property="twitter:description" content="Documentation for Automa.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Automa.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../theory/">Theory</a></li><li><a class="tocitem" href="../regex/">Regex</a></li><li><a class="tocitem" href="../validators/">Validators</a></li><li><a class="tocitem" href="../tokenizer/">Tokenizers</a></li><li><a class="tocitem" href="../parser/">Parsing buffers</a></li><li><a class="tocitem" href="../custom/">Customizing codegen</a></li><li class="is-active"><a class="tocitem" href>Parsing IOs</a><ul class="internal"><li><a class="tocitem" href="#Example-use"><span>Example use</span></a></li><li><a class="tocitem" href="#Reading-a-single-record"><span>Reading a single record</span></a></li><li><a class="tocitem" href="#Preserving-data-by-marking-the-buffer"><span>Preserving data by marking the buffer</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../reader/">Creating readers</a></li><li><a class="tocitem" href="../debugging/">Debugging Automa</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Parsing IOs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parsing IOs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/BioJulia/Automa.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/BioJulia/Automa.jl/blob/master/docs/src/io.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Parsing-from-an-IO"><a class="docs-heading-anchor" href="#Parsing-from-an-IO">Parsing from an IO</a><a id="Parsing-from-an-IO-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing-from-an-IO" title="Permalink"></a></h1><p>Some file types are gigabytes or tens of gigabytes in size. For these files, parsing from a buffer may be impractical, as they require you to read in the entire file in memory at once. Automa enables this by hooking into <code>TranscodingStreams.jl</code>, a package that provides a wrapper IO of the type <code>TranscodingStream</code>. Importantly, these streams buffer their input data. Automa is thus able to operate directly on the input buffers of <code>TranscodingStream</code> objects.</p><p>Unfortunately, this <em>significantly</em> complicates things compared to parsing from a simple buffer. The main problem is that, when reading from a buffered stream, the byte array visible from <code>Automa</code> is only a small slice of the total input data. Worse, when the end of the stream is reached, data from the buffer is flushed, i.e. removed from the stream. To handle this, Automa must reach deep into the implementation details of <code>TranscodingStreams</code>, and also break some of its own abstractions. It&#39;s not pretty, but it&#39;s what we have.</p><p>Practically speaking, parsing from IO is done with the function <code>Automa.generate_reader</code>. Despite its name, this function is NOT directly used to generate objects like <code>FASTA.Reader</code>. Instead, this function produces Julia code (an <code>Expr</code> object) that, when evaluated, defines a function that can execute an Automa machine on an IO. Let me first show the code generated by <code>generate_reader</code> in pseudocode format:</p><pre><code class="nohighlight hljs">function { function name }(stream::TranscodingStream, { args... })
    { init code }

    @label __exec__

    p = current buffer position
    p_end = final buffer position

    # the eof call below will first flush any used data from buffer,
    # then load in new data, before checking if it&#39;s really eof.
    is_eof = eof(stream)
    execute normal automa parsing of the buffer
    update buffer position to match p

    { loop code }

    if cs &lt; 0 # meaning: erroneous input or erroneous EOF
        { error code }
    end

    if machine errored or reached EOF
        @label __return__
        { return code }
    end
    @goto __exec__
end</code></pre><p>The content marked <code>{ function name }</code>, <code>{ args... }</code>, <code>{ init code }</code>, <code>{ loop code }</code>, <code>{ error code }</code> and <code>{ return code }</code> are arguments provided to <code>Automa.generate_reader</code>. By providing these, the user can customize the generated function further.</p><p>The main difference from the code generated to parse a buffer is the label/GOTO pair <code>__exec__</code>, which causes Automa to repeatedly load data into the buffer, execute the machine, then flush used data from the buffer, then execute the machine, and so on, until interrupted.</p><p>Importantly, when parsing from a buffer, <code>p</code> and <code>p_end</code> refer to the position <em>in the current buffer</em>. This may not be the position in the stream, and when the data in the buffer is flushed, it may move the data in the buffer so that <code>p</code> now become invalid. This means you can&#39;t simply store a variable <code>marked_pos</code> that points to the current value of <code>p</code> and expect that the same data is at that position later. Furthermore, <code>is_eof</code> is set to whether the stream has reached EOF.</p><h2 id="Example-use"><a class="docs-heading-anchor" href="#Example-use">Example use</a><a id="Example-use-1"></a><a class="docs-heading-anchor-permalink" href="#Example-use" title="Permalink"></a></h2><p>Let&#39;s show the simplest possible example of such a function. We have a <code>Machine</code> (which, recall, is a compiled regex) called <code>machine</code>, and we want to make a function that returns <code>true</code> if a given <code>IO</code> contain data that conforms to the regex format specified by the <code>Machine</code>.</p><p>We will still use the machine from before, just without any actions:</p><pre><code class="language-julia hljs">machine = let
    header = re&quot;[a-z]+&quot;
    seqline = re&quot;[ACGT]+&quot;
    record = re&quot;&gt;&quot; * header * &#39;\n&#39; * rep1(seqline * &#39;\n&#39;)
    compile(rep(record))
end
@assert machine isa Automa.Machine</code></pre><p>To create our simple IO reader, we simply need to call <code>generate_reader</code>, where the <code>{ return code }</code> is a check if <code>iszero(cs)</code>, meaning if the machine exited at a proper exit state. We also need to set <code>error_code</code> to an empty expression in order to prevent throwing an error on invalid code. Instead, we want it to go immediately to return - we call this section <code>__return__</code>, so we need to <code>@goto __return__</code>. Then, we need to evaluate the code created by <code>generate_reader</code> in order to define the function <code>validate_fasta</code></p><pre><code class="language-julia-repl hljs">julia&gt; return_code = :(iszero(cs));

julia&gt; error_code = :(@goto __return__);

julia&gt; eval(generate_reader(:validate_fasta,  machine; returncode=return_code, errorcode=error_code));</code></pre><p>The generated function <code>validate_fasta</code> has the function signature: <code>validate_fasta(stream::TranscodingStream)</code>. If our input IO is not a <code>TranscodingStream</code>, we can wrap it in the relatively lightweight <code>NoopStream</code>, which, as the name suggests, does nothing to the data:</p><pre><code class="language-julia-repl hljs">julia&gt; io = NoopStream(IOBuffer(&quot;&gt;a\nTAG\nTA\n&gt;bac\nG\n&quot;));

julia&gt; validate_fasta(io)
true

julia&gt; validate_fasta(NoopStream(IOBuffer(&quot;random data&quot;)))
false</code></pre><h2 id="Reading-a-single-record"><a class="docs-heading-anchor" href="#Reading-a-single-record">Reading a single record</a><a id="Reading-a-single-record-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-a-single-record" title="Permalink"></a></h2><div class="admonition is-danger"><header class="admonition-header">Danger</header><div class="admonition-body"><p>The following code is only for demonstration purposes. It has one important flaw, which will be addressed in a later section, so do not copy-paste it for serious work.</p></div></div><p>There are a few more subtleties related to the <code>generate_reader</code> function. Suppose we instead want to create a function that reads a single FASTA record from an IO. In this case, it&#39;s no good that the function created from <code>generate_reader</code> will loop until the IO reaches EOF - we need to find a way to stop it after reading a single record. We can do this with the pseudomacro <code>@escape</code>, as shown below.</p><p>We will reuse our <code>Seq</code> struct and our <code>Machine</code> from the &quot;parsing from a buffer&quot; section of this tutorial:</p><pre><code class="language-julia hljs">struct Seq
    name::String
    seq::String
end

machine = let
    header = onexit!(onenter!(re&quot;[a-z]+&quot;, :mark_pos), :header)
    seqline = onexit!(onenter!(re&quot;[ACGT]+&quot;, :mark_pos), :seqline)
    record = onexit!(re&quot;&gt;&quot; * header * &#39;\n&#39; * rep1(seqline * &#39;\n&#39;), :record)
    compile(rep(record))
end
@assert machine isa Automa.Machine

# output</code></pre><p>The code below contains <code>@escape</code> in the <code>:record</code> action - meaning: Break out of machine execution.</p><pre><code class="language-julia hljs">actions = Dict{Symbol, Expr}(
    :mark_pos =&gt; :(pos = p),
    :header =&gt; :(header = String(data[pos:p-1])),
    :seqline =&gt; :(append!(seqbuffer, data[pos:p-1])),

    # Only this action is different from before!
    :record =&gt; quote
        seq = Seq(header, String(seqbuffer))
        found_sequence = true
        # Reset p one byte if we&#39;re not at the end
        p -= !(is_eof &amp;&amp; p &gt; p_end)
        @escape
    end
)
@assert actions isa Dict

# output</code></pre><p><code>@escape</code> is not actually a real macro, but what Automa calls a &quot;pseudomacro&quot;. It is expanded during Automa&#39;s own compiler pass <em>before</em> Julia&#39;s lowering. The <code>@escape</code> pseudomacro is replaced with code that breaks it out of the executing machine, without reaching EOF or an invalid byte.</p><p>Let&#39;s see how I use <code>generate_reader</code>, then I will explain each part:</p><pre><code class="language-julia hljs">generate_reader(
    :read_record,
    machine;
    actions=actions,
    initcode=quote
        seqbuffer = UInt8[]
        pos = 0
        found_sequence = false
        header = &quot;&quot;
    end,
    loopcode=quote
        if (is_eof &amp;&amp; p &gt; p_end) || found_sequence
            @goto __return__
        end
    end,
    returncode=:(found_sequence ? seq : nothing)
) |&gt; eval</code></pre><p>In the <code>:record</code>, action, a few new things happen.</p><ul><li>First, I set the flag <code>found_sequence = false</code>. In the loop code, I look for this flag to signal that the function should return. Remember, the loop code happens after machine execution, which can mean either that the execution was broken out of by <code>@escape</code>, or than the buffer ran out and need to be refilled. I could just return the sequence directly in the action, but then I would skip a bunch of the code generated by <code>generate_reader</code> which sets the buffer state correctly, <em>so this is never adviced</em>. Instead, in the <em>loop code</em>, which executes after the buffer has been flushed, I check for this flag, and goes to <code>__return__</code> if necessary. I could also just return directly in the loopcode, but I prefer only having one place to retun from the function.</li><li>I use <code>@escape</code> to break out of the machine, i.e. stop machine execution</li><li>Finally, I decrement <code>p</code>, if and only if the machine has not reached EOF (which happens when <code>is_eof</code> is true, meaning the last part of the IO has been buffered, and <code>p &gt; p_end</code>, meaning the end of the buffer has been reached). This is because, the first record ends when the IO reads the second <code>&gt;</code> symbol. If I then were to read another record from the same IO, I would have already read the <code>&gt;</code> symbol. I need to reset <code>p</code> by 1, so the <code>&gt;</code> is also read on the next call to <code>read_record</code>.</li></ul><p>I can use the function like this:</p><pre><code class="language-julia-repl hljs">julia&gt; io = NoopStream(IOBuffer(&quot;&gt;a\nT\n&gt;tag\nGAGA\nTATA\n&quot;));

julia&gt; read_record(io)
Seq(&quot;a&quot;, &quot;T&quot;)

julia&gt; read_record(io)
Seq(&quot;tag&quot;, &quot;GAGATATA&quot;)

julia&gt; read_record(io)</code></pre><h2 id="Preserving-data-by-marking-the-buffer"><a class="docs-heading-anchor" href="#Preserving-data-by-marking-the-buffer">Preserving data by marking the buffer</a><a id="Preserving-data-by-marking-the-buffer-1"></a><a class="docs-heading-anchor-permalink" href="#Preserving-data-by-marking-the-buffer" title="Permalink"></a></h2><p>There are several problems with the implementation above: The following code in my actions dict:</p><pre><code class="language-julia hljs">header = String(data[pos:p-1])</code></pre><p>Creates <code>header</code> by accessing the data buffer. However, when reading an IO, how can I know that the data hasn&#39;t shifted around in the buffer between when I defined <code>pos</code>? For example, suppose we have a short buffer of only 8 bytes, and the following FASTA file: <code>&gt;abcdefghijkl\nA</code>. Then, the buffer is first filled with <code>&gt;abcdefg</code>. When entering the header, I execute the action <code>:mark_position</code> at <code>p = 2</code>, so <code>pos = 2</code>. But now, when I reach the end of the header, the used data in the buffer has been flushed, and the data is now: <code>hijkl\nA</code>, and <code>p = 14</code>. I then try to access <code>data[2:13]</code>, which is out of bounds!</p><p>Luckily, the buffers of <code>TranscodingStreams</code> allow us to &quot;mark&quot; a position to save it. The buffer will not flush the marked position, or any position after the marked position. If necessary, it will resize the buffer to be able to load more data while keeping the marked position.</p><p>Inside the function generated by <code>generate_reader</code>, we can use the zero-argument pseudomacro <code>@mark()</code>, which marks the position <code>p</code>. The macro <code>@markpos()</code> can then be used to get the marked position, which will point to the same data in the buffer, even after the data in the buffer has been shifted after it&#39;s been flushed. This works because the mark is stored inside the <code>TranscodingStream</code> buffer, and the buffer makes sure to update the mark if the content moves. Hence, we can re-write the actions:</p><pre><code class="language-julia hljs">actions = Dict{Symbol, Expr}(
    :mark_position =&gt; :(@mark),
    :header =&gt; :(header = String(data[@markpos():p-1])),
    :seqline =&gt; :(append!(buffer, data[@markpos():p-1])),

    [:record action omitted...]
)</code></pre><p>In our example above with the small 8-byte buffer, this is what would happen: First, the buffer contains the first 8 bytes. When <code>p = 2</code>, the mark is set, and the second byte is marked::</p><pre><code class="nohighlight hljs">content: &gt;abcdefg
mark:     ^
p = 2     ^</code></pre><p>Then, when <code>p = 9</code> the buffer is exhausted, the used data is removed, BUT, the mark stays, so byte 2 is preserved, and only the first byte is removed. The code in <code>generate_reader</code> loops around to <code>@label __exec__</code>, which sets p to the current buffer position. The buffer now looks like this:</p><pre><code class="nohighlight hljs">content: abcdefgh
mark:    ^
p = 8           ^</code></pre><p>Only 1 byte was cleared, so when <code>p = 9</code>, the buffer will be exhausted again. This time, no data can be cleared, so instead, the buffer is resized to fit more data:</p><pre><code class="nohighlight hljs">content: abcdefghijkl\nA
mark:    ^
p = 9            ^</code></pre><p>Finally, when we reach the newline <code>p = 13</code>, the whole header is in the buffer, and so <code>data[@markpos():p-1]</code> will correctly refer to the header (now, <code>1:12</code>).</p><pre><code class="nohighlight hljs">content: abcdefghijkl\nA
mark:    ^
p = 13               ^</code></pre><p>Remember to update the mark, or to clear it with <code>@unmark()</code> in order to be able to flush data from the buffer afterwards.</p><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.generate_reader" href="#Automa.generate_reader"><code>Automa.generate_reader</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_reader(funcname::Symbol, machine::Automa.Machine; kwargs...)</code></pre><p>Generate a streaming reader function of the name <code>funcname</code> from <code>machine</code>.</p><p>The generated function consumes data from a stream passed as the first argument and executes the machine with filling the data buffer.</p><p>This function returns an expression object of the generated function.  The user need to evaluate it in a module in which the generated function is needed.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>arguments</code>: Additional arguments <code>funcname</code> will take (default: <code>()</code>).   The default signature of the generated function is <code>(stream::TranscodingStream,)</code>,   but it is possible to supply more arguments to the signature with this keyword argument.</li><li><code>context</code>: Automa&#39;s codegenerator (default: <code>Automa.CodeGenContext()</code>).</li><li><code>actions</code>: A dictionary of action code (default: <code>Dict{Symbol,Expr}()</code>).</li><li><code>initcode</code>: Initialization code (default: <code>:()</code>).</li><li><code>loopcode</code>: Loop code (default: <code>:()</code>).</li><li><code>returncode</code>: Return code (default: <code>:(return cs)</code>).</li><li><code>errorcode</code>: Executed if <code>cs &lt; 0</code> after <code>loopcode</code> (default error message)</li></ul><p>See the source code of this function to see how the generated code looks like</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/cfaa5294326b342428a051399a360b99322ce4cc/src/stream.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.@escape" href="#Automa.@escape"><code>Automa.@escape</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@escape()</code></pre><p>Pseudomacro. When encountered during <code>Machine</code> execution, the machine will stop executing. This is useful to interrupt the parsing process, for example to emit a record during parsing of a larger file. <code>p</code> will be advanced as normally, so if <code>@escape</code> is hit on <code>B</code> during parsing of <code>&quot;ABC&quot;</code>, the next byte will be <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/cfaa5294326b342428a051399a360b99322ce4cc/src/codegen.jl#L724-L732">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.@mark" href="#Automa.@mark"><code>Automa.@mark</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@mark()</code></pre><p>Pseudomacro, to be used with IO-parsing Automa functions. This macro will &quot;mark&quot; the position of <code>p</code> in the current buffer. The marked position will not be flushed from the buffer after being consumed. For example, Automa code can call <code>@mark()</code> at the beginning of a large string, then when the string is exited at position <code>p</code>, it is guaranteed that the whole string resides in the buffer at positions <code>markpos():p-1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/cfaa5294326b342428a051399a360b99322ce4cc/src/codegen.jl#L737-L746">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.@unmark" href="#Automa.@unmark"><code>Automa.@unmark</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">unmark()</code></pre><p>Pseudomacro. Removes the mark from the buffer. This allows all previous data to be cleared from the buffer.</p><p>See also: <a href="#Automa.@mark"><code>@mark</code></a>, <a href="#Automa.@markpos"><code>@markpos</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/cfaa5294326b342428a051399a360b99322ce4cc/src/codegen.jl#L751-L758">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.@markpos" href="#Automa.@markpos"><code>Automa.@markpos</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">markpos()</code></pre><p>Pseudomacro. Get the position of the mark in the buffer.</p><p>See also: <a href="#Automa.@mark"><code>@mark</code></a>, <a href="#Automa.@markpos"><code>@markpos</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/cfaa5294326b342428a051399a360b99322ce4cc/src/codegen.jl#L763-L769">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.@bufferpos" href="#Automa.@bufferpos"><code>Automa.@bufferpos</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">bufferpos()</code></pre><p>Pseudomacro. Returns the integer position of the current <code>TranscodingStreams</code> buffer (only used with the <code>generate_reader</code> function).</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs"># Inside some Automa action code
@setbuffer()
description = sub_parser(stream)
p = @bufferpos()</code></pre><p>See also: <a href="#Automa.@setbuffer"><code>@setbuffer</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/cfaa5294326b342428a051399a360b99322ce4cc/src/codegen.jl#L774-L789">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.@relpos" href="#Automa.@relpos"><code>Automa.@relpos</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">relpos(p)</code></pre><p>Automa pseudomacro. Return the position of <code>p</code> relative to <code>@markpos()</code>. Equivalent to <code>p - @markpos() + 1</code>. This can be used to mark additional points in the stream when the mark is set, after which their action position can be retrieved using <code>abspos(x)</code>.</p><p>Behaviour is undefined if mark has not yet been set.</p><p><strong>Example usage:</strong></p><pre><code class="nohighlight hljs"># In one action
identifier_pos = @relpos(p)

# Later, in a different action
identifier = data[@abspos(identifier_pos):p]</code></pre><p>See also: <a href="#Automa.@abspos"><code>@abspos</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/cfaa5294326b342428a051399a360b99322ce4cc/src/codegen.jl#L794-L814">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.@abspos" href="#Automa.@abspos"><code>Automa.@abspos</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">abspos(p)</code></pre><p>Automa pseudomacro. Used to obtain the actual position of a relative position obtained from <code>@relpos</code>. See <a href="#Automa.@relpos"><code>@relpos</code></a> for more details.</p><p>Behaviour is undefined if mark has not yet been set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/cfaa5294326b342428a051399a360b99322ce4cc/src/codegen.jl#L819-L826">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.@setbuffer" href="#Automa.@setbuffer"><code>Automa.@setbuffer</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">setbuffer()</code></pre><p>Updates the buffer position to match <code>p</code>. The buffer position is syncronized with <code>p</code> before and after calls to functions generated by <code>generate_reader</code>. <code>@setbuffer()</code> can be used to the buffer before calling another parser.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs"># Inside some Automa action code
@setbuffer()
description = sub_parser(stream)
p = @bufferpos()</code></pre><p>See also: <a href="#Automa.@bufferpos"><code>@bufferpos</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/cfaa5294326b342428a051399a360b99322ce4cc/src/codegen.jl#L831-L848">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../custom/">« Customizing codegen</a><a class="docs-footer-nextpage" href="../reader/">Creating readers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 15 January 2024 15:56">Monday 15 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
