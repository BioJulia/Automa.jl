```@meta
CurrentModule = Automa
DocTestSetup = quote
    using TranscodingStreams
    using Automa
end
```

# Parsing from an IO

!!! note
    Parsing from an IO relies on TranscodingStreams.jl, and the relevant methods are defined in an extension module in Automa.
    If you use Julia 1.9 or later, you must load TranscodingStreams before loading Automa to test this functionality.

Some file types are gigabytes or tens of gigabytes in size.
For these files, parsing from a buffer may be impractical, as they require you to read in the entire file in memory at once.
Automa enables this by hooking into `TranscodingStreams.jl`, a package that provides a wrapper IO of the type `TranscodingStream`.
Importantly, these streams buffer their input data.
Automa is thus able to operate directly on the input buffers of `TranscodingStream` objects.

Unfortunately, this _significantly_ complicates things compared to parsing from a simple buffer.
The main problem is that, when reading from a buffered stream, the byte array visible from `Automa` is only a small slice of the total input data.
Worse, when the end of the stream is reached, data from the buffer is flushed, i.e. removed from the stream.
To handle this, Automa must reach deep into the implementation details of `TranscodingStreams`, and also break some of its own abstractions.
It's not pretty, but it's what we have.

Practically speaking, parsing from IO is done with the function `Automa.generate_reader`.
Despite its name, this function is NOT directly used to generate objects like `FASTA.Reader`.
Instead, this function produces Julia code (an `Expr` object) that, when evaluated, defines a function that can execute an Automa machine on an IO.
Let me show the code in pseudocode generated by `generate_reader` format first:

```
function { function name }(stream::TranscodingStream, { args... })
    { init code }

    @label EXECUTE_MACHINE

    is_eof = eof(stream)
    p = current_buffer_position
    p_end = final_buffer_position

    load new data into buffer, if any
    is_eof = eof(stream)
    execute normal automa parsing of the buffer
    flush any used up data from the buffer

    { loop code }

    if machine errored or reached EOF
        { return code }
    end
    @goto EXECUTE_MACHINE
end
```

The content marked `{ function name }`, `{ args... }`, `{ init code }`, `{ loop code }` and `{ return code }` are arguments provided to `Automa.generate_reader`.
By providing these, the user can customize the generated function further.

The main difference from the code generated to parse a buffer is the label/GOTO pair `EXECUTE MACHINE`, which causes Automa to repeatedly load data into the buffer, execute the machine, then flush used data from the buffer, then execute the machine, and so on, until interrupted.

Importantly, `p` and `p_end` is continuously updated in this loop, as flushing the data may move data around such that these changes.
This means you can't simply store a variable `marked_pos` that points to the current value of `p` and expect that the same data is at that position later.
Furthermore, `is_eof` is set to whether the stream has reached EOF.

## Example use
Let's show the simplest possible example of such a function.
We have a `Machine` (which, recall, is a compiled regex) called `machine`, and we want to make a function that returns `true` if a given `IO` contain data that conforms to the regex format specified by the `Machine`.

We will still use the machine from before, just without any actions:

```jldoctest io1; output = false
machine = let
    header = re"[a-z]+"
    seqline = re"[ACGT]+"
    record = re">" * header * '\n' * rep1(seqline * '\n')
    compile(rep(record))
end
@assert machine isa Automa.Machine

# output

```

To create our simple IO reader, we simply need to call `generate_reader`, where the `{ return code }` is a check if `iszero(cs)`, meaning if the machine exited at a proper exit state.
We also need to set `error_code` to an empty expression in order to prevent throwing an error on invalid code. Instead, we want it to go immediately to return - we call this section `__return__`, so we need to `@goto __return__`.
Then, we need to evaluate the code created by `generate_reader` in order to define the function `validate_fasta`

```jldoctest io1
julia> return_code = :(iszero(cs));

julia> eval(generate_reader(:validate_fasta, machine; returncode=return_code, errorcode=:(@goto __return__)));
```

The generated function `validate_fasta` has the function signature:
`validate_fasta(stream::TranscodingStream)`

Remember that the generated function must take a `TranscodingStream`.
If our input IO is not a `TranscodingStream`, we can wrap it in the relatively lightweight `NoopStream`, which, as the name suggests, does nothing to the data:

```jldoctest io1
julia> io = NoopStream(IOBuffer(">a\nTAG\nTA\n>bac\nG\n"));

julia> validate_fasta(io)
true

julia> validate_fasta(NoopStream(IOBuffer("random data")))
false
```

## Reading a single record

!!! danger
    The following code is only for demonstration purposes.
    It has several important flaws, which will be adressed in a later section, so do not copy-paste it for serious work.

There are a few more subtleties related to the `generate_reader` function.
Suppose we instead want to create a function that reads a single FASTA record from an IO.
In this case, it's no good that the function created from `generate_reader` will loop until the IO reaches EOF - we need to find a way to stop it.
We do this by stopping the machine execution at certain points - for example, if the machine has created a FASTA record.

We will reuse our `Seq` struct and our `Machine` from the "parsing from a buffer" section of this tutorial:

```jldoctest io2; output = false
struct Seq
    name::String
    seq::String
end

machine = let
    header = onexit!(onenter!(re"[a-z]+", :mark_pos), :header)
    seqline = onexit!(onenter!(re"[ACGT]+", :mark_pos), :seqline)
    record = onexit!(re">" * header * '\n' * rep1(seqline * '\n'), :record)
    compile(rep(record))
end
@assert machine isa Automa.Machine

# output
```

We will also mostly re-use the actions, with the minor difference that when creating a `Seq`, instead of pushing onto a vector of sequences,
we will use the pseudo-macro `@escape`, which will escape out of the machine:

```jldoctest io2; output = false
actions = Dict{Symbol, Expr}(
    :mark_pos => :(pos = p),
    :header => :(header = String(data[pos:p-1])),
    :seqline => :(append!(seqbuffer, data[pos:p-1])),

    # Only this action is different from before!
    :record => quote
        seq = Seq(header, String(seqbuffer))
        found_sequence = true
        # Reset p one byte if we're not at the end
        p -= !(is_eof && p > p_end)
        @escape
    end
)
@assert actions isa Dict

# output
```

`@escape` is not actually a real macro, but what Automa calls a "pseudomacro".
It is expanded during Automa's own compiler pass _before_ Julia's lowering.
The `@escape` pseudomacro is replaced with code that breaks it out of the executing machine, without reaching EOF or an invalid byte.

Let's see how I use `generate_reader`, then I will explain each part:

```jldoctest io2; output = false
generate_reader(
    :read_record,
    machine;
    actions=actions,
    initcode=quote
        seqbuffer = UInt8[]
        pos = 0
        found_sequence = false
        header = ""
    end,
    loopcode=quote
        if (is_eof && p > p_end) || found_sequence
            @goto __return__
        end
    end,
    returncode=:(found_sequence ? seq : nothing)
) |> eval

# output
read_record (generic function with 1 method)
```

In the `:record`, action, a few new things happen.
* First, I set the flag `found_sequence = true`.
  In the loop code, I look for this flag to signal that the function should return.
  I could just return the sequence directly, but then I would skip a bunch of the code generated by `generate_reader` which sets the buffer state correctly.
  Instead, in the _loop code_, which executes after the buffer has been flushed, I check for this flag, and goes to `__return__` if necessary.
  I could also just return directly in the loopcode, but I prefer only having one place to retun from the function.
* I use `@escape` to break out of the machine, i.e. stop machine execution
* Finally, I decrement `p`, if and only if the machine has not reached EOF (which happens when `is_eof` is true, meaning the last part of the IO has been buffered, and `p > p_end`, meaning the end of the buffer has been reached).
  This is because, the first record ends when the IO reads the second `>` symbol.
  If I then were to read another record from the same IO, I would have already read the `>` symbol.
  I need to reset `p` by 1, so the `>` is also read on the next call to `read_record`.

I can use the function like this:

```jldoctest io2
julia> io = NoopStream(IOBuffer(">a\nT\n>tag\nGAGA\nTATA\n"));

julia> read_record(io)
Seq("a", "T")

julia> read_record(io)
Seq("tag", "GAGATATA")

julia> read_record(io)
```

## Preserving data by marking the buffer
There are several problems with the implementation above: The following code in my actions dict:

```julia
header = String(data[pos:p-1])
```

Creates `header` by accessing the data buffer.
However, when reading an IO, how can I know that the data hasn't shifted around in the buffer between when I defined `pos`?
For example, suppose we have a short buffer of only 8 bytes, and the following FASTA file: `>abcdefghijkl\nA`.
Then, the buffer is first filled with `>abcdefg`.
When entering the header, I execute the action `:mark_position` at `p = 2`, so `pos = 2`.
But now, when I reach the end of the header, the used data in the buffer has been flushed, and the data is now:
`hijkl\nA`, and `p = 14`.
I then try to access `data[2:13]`, which is out of bounds!

Luckily, the buffers of `TranscodingStreams` allow us to "mark" a position to save it.
The buffer will not discard the marked position, or any position after the marked position.
Inside the function generated by `generate_reader`, we can use the zero-argument pseudomacro `@mark()`, which marks the position `p`.
The macro `@markpos()` can then be used to get the marked position, even if its value has been moved by the buffer.
This works because the mark is stored inside the `TranscodingStream` buffer, and the buffer makes sure to update the mark if the content moves.
Hence, we can re-write the actions:

```julia
actions = Dict{Symbol, Expr}(
    :mark_position => :(@mark),
    :header => :(header = String(data[@markpos():p-1])),
    :seqline => :(append!(buffer, data[@markpos():p-1])),

    [:record action omitted...]
)
```

In our example above with the small 8-byte buffer, this is what would happen:
First, the buffer contains the first 8 bytes.
When `p = 2`, the mark is set, and the second byte is marked::

```
content: >abcdefg
mark:     ^
p = 2     ^
```

Then, when `p = 9` the buffer is exhausted, the used data is removed, BUT, the mark stays, so only 2 bytes are moved.
Since two bytes were moved, `p` is decremented to `7`
The buffer now looks like this:

```
content: abcdefgh
mark:    ^
p = 7          ^
```

Only 2 bytes was cleared, so when `p = 9`, the buffer will be exhausted again.
This time, no data can be cleared, so instead, the buffer is resized to fit more data:

```
content: abcdefghijkl\nA
mark:    ^
p = 9            ^
```

And so everything works.

## Reference
```@docs
Automa.generate_reader
Automa.@escape
Automa.@mark
Automa.@unmark
Automa.@markpos
Automa.@bufferpos
Automa.@relpos
Automa.@abspos
Automa.@setbuffer
```