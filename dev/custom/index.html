<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Customizing codegen · Automa.jl</title><meta name="title" content="Customizing codegen · Automa.jl"/><meta property="og:title" content="Customizing codegen · Automa.jl"/><meta property="twitter:title" content="Customizing codegen · Automa.jl"/><meta name="description" content="Documentation for Automa.jl."/><meta property="og:description" content="Documentation for Automa.jl."/><meta property="twitter:description" content="Documentation for Automa.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Automa.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../theory/">Theory</a></li><li><a class="tocitem" href="../regex/">Regex</a></li><li><a class="tocitem" href="../validators/">Validators</a></li><li><a class="tocitem" href="../tokenizer/">Tokenizers</a></li><li><a class="tocitem" href="../parser/">Parsing buffers</a></li><li class="is-active"><a class="tocitem" href>Customizing codegen</a><ul class="internal"><li><a class="tocitem" href="#Using-CodeGenContext"><span>Using <code>CodeGenContext</code></span></a></li><li><a class="tocitem" href="#Optimising-the-previous-example"><span>Optimising the previous example</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../io/">Parsing IOs</a></li><li><a class="tocitem" href="../reader/">Creating readers</a></li><li><a class="tocitem" href="../debugging/">Debugging Automa</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Customizing codegen</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Customizing codegen</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/BioJulia/Automa.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/BioJulia/Automa.jl/blob/master/docs/src/custom.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Customizing-Automa&#39;s-code-generation"><a class="docs-heading-anchor" href="#Customizing-Automa&#39;s-code-generation">Customizing Automa&#39;s code generation</a><a id="Customizing-Automa&#39;s-code-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Customizing-Automa&#39;s-code-generation" title="Permalink"></a></h1><p>Automa offers a few ways of customising the created code. Note that the precise code generated by Automa is considered an implementation detail, and as such is subject to change without warning. Only the overall behavior, i.e. the &quot;DFA simulation&quot; can be considered stable.</p><p>Nonetheless, it is instructive to look at the code generated for the machine in the &quot;parsing from a buffer&quot; <a href="../parser/#Creating-our-parser">section</a>. I present it here cleaned up and with comments for human inspection.</p><pre><code class="language-julia hljs"># Initialize variables used in the code below
byte::UInt8 = 0x00
p::Int = 1
p_end::Int = sizeof(data)
p_eof::Int = p_end
cs::Int = 1

# Turn the input buffer into SizedMemory, to load data from pointer
GC.@preserve data begin
mem::Automa.SizedMemory = (Automa.SizedMemory)(data)

# For every input byte:
while p ≤ p_end &amp;&amp; cs &gt; 0
    # Load byte
    byte = mem[p]

    # Load the action, to execute, if any, by looking up in a table
    # using the current state (cs) and byte
    @inbounds var&quot;##292&quot; = Int((Int8[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0])[(cs - 1) &lt;&lt; 8 + byte + 1])

    # Look up next state. If invalid input, next state is negative current state
    @inbounds cs = Int((Int8[-1 -2 … -5 -6; -1 -2 … -5 -6; … ; -1 -2 … -5 -6; -1 -2 … -5 -6])[(cs - 1) &lt;&lt; 8 + byte + 1])

    # Check each possible action looked up above, and execute it
    # if it is not zero
    if var&quot;##292&quot; == 1
        pos = p
    elseif var&quot;##292&quot; == 2
        header = String(data[pos:p - 1])
    elseif if var&quot;##292&quot; == 3
        append!(buffer, data[pos:p - 1])
    elseif var&quot;##292&quot; == 4
        seq = Seq(header, String(buffer))
        push!(seqs, seq)
    end

    # Increment position by 1
    p += 1

    # If we&#39;re at end of input, and the current state in in an accept state:
    if p &gt; p_eof ≥ 0 &amp;&amp; cs &gt; 0 &amp;&amp; (cs &lt; 65) &amp; isodd(0x0000000000000021 &gt;&gt;&gt; ((cs - 1) &amp; 63))
        # What follows is a list of all possible EOF actions.

        # If state is state 6, execute the appropriate action
        # tied to reaching end of input at this state
        if cs == 6
            seq = Seq(header, String(buffer))
            push!(seqs, seq)
            cs = 0

    # Else, if the state is &lt; 0, we have taken a bad input (see where cs was updated)
    # move position back by one to leave it stuck where it found bad input
    elseif cs &lt; 0
        p -= 1
    end

    # If cs is not 0, the machine is in an error state.
    # Gather some information about machine state, then throw an error
    if cs != 0
        cs = -(abs(cs))
        var&quot;##291&quot; = if p_eof &gt; -1 &amp;&amp; p &gt; p_eof
            nothing
        else
            byte
        end
        Automa.throw_input_error($machine, -cs, var&quot;##291&quot;, mem, p)
    end
end
end # GC.@preserve</code></pre><h2 id="Using-CodeGenContext"><a class="docs-heading-anchor" href="#Using-CodeGenContext">Using <code>CodeGenContext</code></a><a id="Using-CodeGenContext-1"></a><a class="docs-heading-anchor-permalink" href="#Using-CodeGenContext" title="Permalink"></a></h2><p>The <code>CodeGenContext</code> (or ctx, for short) struct is a collection of settings used to customize code creation. If not passed to the code generator functions, a default <code>CodeGenContext</code> is used.</p><h3 id="Variable-names"><a class="docs-heading-anchor" href="#Variable-names">Variable names</a><a id="Variable-names-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-names" title="Permalink"></a></h3><p>One obvious place to customize is variable names. In the code above, for example, the input bytes are named <code>byte</code>. What if you have another variable with that name?</p><p>The ctx contains a <code>.vars</code> field with a <code>Variables</code> object, which is just a collection of names used in generated code. For example, to rename <code>byte</code> to <code>u8</code> in the generated code, you first create the appropriate ctx, then use the ctx to make the code.</p><pre><code class="language-julia hljs">ctx = CodeGenContext(vars=Automa.Variables(byte=:u8))
code = generate_code(ctx, machine, actions)</code></pre><h3 id="Other-options"><a class="docs-heading-anchor" href="#Other-options">Other options</a><a id="Other-options-1"></a><a class="docs-heading-anchor-permalink" href="#Other-options" title="Permalink"></a></h3><ul><li>The <code>clean</code> option strips most linenumber information from the generated code, if set to true.</li><li><code>getbyte</code> is a function that is called like this <code>getbyte(data, p)</code> to obtain <code>byte</code> in the main loop. This is usually just <code>Base.getindex</code>, but can be customised to be an arbitrary function.</li></ul><h3 id="Code-generator"><a class="docs-heading-anchor" href="#Code-generator">Code generator</a><a id="Code-generator-1"></a><a class="docs-heading-anchor-permalink" href="#Code-generator" title="Permalink"></a></h3><p>The code showed at the top of this page is code made with the table code generator. Automa also supports creating code using the goto code generator instead of the default table generator. The goto generator creates code with the following properties:</p><ul><li>It is much harder to read than table code</li><li>The code is much larger</li><li>It does not use boundschecking</li><li>It does not allow customizing <code>getbyte</code></li><li>It is much faster than the table generator</li></ul><p>Normally, the table generator is good enough, but for performance sensitive applications, the goto generator can be used.</p><h2 id="Optimising-the-previous-example"><a class="docs-heading-anchor" href="#Optimising-the-previous-example">Optimising the previous example</a><a id="Optimising-the-previous-example-1"></a><a class="docs-heading-anchor-permalink" href="#Optimising-the-previous-example" title="Permalink"></a></h2><p>Let&#39;s try optimising the previous FASTA parsing example. My original code did 300 MB/s.</p><p>To recap, the <code>Machine</code> was:</p><pre><code class="language-julia hljs">machine = let
    header = onexit!(onenter!(re&quot;[a-z]+&quot;, :mark_pos), :header)
    seqline = onexit!(onenter!(re&quot;[ACGT]+&quot;, :mark_pos), :seqline)
    record = onexit!(re&quot;&gt;&quot; * header * &#39;\n&#39; * rep1(seqline * &#39;\n&#39;), :record)
    compile(rep(record))
end
@assert machine isa Automa.Machine</code></pre><p>The first improvement is to the algorithm itself: Instead of parsing to a vector of <code>Seq</code>, I&#39;m simply going to index the input data, filling up an existing vector of:</p><pre><code class="language-julia hljs">struct SeqPos
    offset::Int
    hlen::Int32
    slen::Int32
end</code></pre><p>The idea here is to remove as many allocations as possible. This will more accurately show the speed of the DFA simulation, which is now the bottleneck. The actions will therefore be </p><pre><code class="language-julia hljs">actions = Dict(
    :mark_pos =&gt; :(pos = p),
    :header =&gt; :(hlen = p - pos),
    :seqline =&gt; :(slen += p - pos),
    :record =&gt; quote
        seqpos = SeqPos(offset, hlen, slen)
        nseqs += 1
        seqs[nseqs] = seqpos
        offset += hlen + slen
        slen = 0
    end
);

@assert actions isa Dict</code></pre><p>With the new variables such as <code>slen</code>, we need to update the function code as well:</p><pre><code class="language-julia hljs">@eval function parse_fasta(data)
    pos = slen = hlen = offset = nseqs = 0
    seqs = Vector{SeqPos}(undef, 400000)
    $(generate_code(machine, actions))
    return seqs
end</code></pre><p>This parses a 45 MB file in about 100 ms in my laptop, that&#39;s 450 MB/s. Now let&#39;s try the exact same, except with the code being generated by:</p><p><code>$(generate_code(CodeGenContext(generator=:goto), machine, actions))</code></p><p>Now the code parses the same 45 MB FASTA file in 11.14 miliseconds, parsing at about 4 GB/s.</p><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.CodeGenContext" href="#Automa.CodeGenContext"><code>Automa.CodeGenContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CodeGenContext(;
    vars=Variables(:p, :p_end, :is_eof, :cs, :data, :mem, :byte, :buffer),
    generator=:table,
    getbyte=Base.getindex,
    clean=false
)</code></pre><p>Create a <code>CodeGenContext</code> (ctx), a struct that stores options for Automa code generation. Ctxs are used for Automa&#39;s various code generator functions. They currently take the following options (more may be added in future versions)</p><ul><li><code>vars::Variables</code>: variable names used in generated code. See the <code>Variables</code> struct.</li><li><code>generator::Symbol</code>: code generator mechanism (<code>:table</code> or <code>:goto</code>). The table generator creates smaller, simpler code that uses a vector of integers to determine state transitions. The goto-generator uses a maze of <code>@goto</code>-statements, and create larger, more complex code, that is faster.</li><li><code>getbyte::Function</code> (table generator only): function <code>f(data, p)</code> to access byte from data. Default: <code>Base.getindex</code>.</li><li><code>clean</code>: Whether to remove some <code>QuoteNode</code>s (line information) from the generated code</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; ctx = CodeGenContext(generator=:goto, vars=Variables(buffer=:tbuffer));

julia&gt; generate_code(ctx, compile(re&quot;a+&quot;)) isa Expr
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/ee6f41b76d4dcbe92052946fc6fa70bb38031866/src/codegen.jl#L65-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.Variables" href="#Automa.Variables"><code>Automa.Variables</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Struct used to store variable names used in generated code. Contained in a <code>CodeGenContext</code>. Create a custom <code>Variables</code> for your <code>CodeGenContext</code> if you want to customize the variables used in Automa codegen, typically if you have conflicting variables with the same name.</p><p>Automa generates code with the following variables, shown below with their default names:</p><ul><li><code>p::Int</code>: current position of data</li><li><code>p_end::Int</code>: end position of data</li><li><code>is_eof::Bool</code>: Whether <code>p_end</code> marks end file stream</li><li><code>cs::Int</code>: current state</li><li><code>data::Any</code>: input data</li><li><code>mem::SizedMemory</code>: Memory wrapping <code>data</code></li><li><code>byte::UInt8</code>: current byte being read from <code>data</code></li><li><code>buffer::TranscodingStreams.Buffer</code>: (<code>generate_reader</code> only)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; ctx = CodeGenContext(vars=Variables(byte=:u8));

julia&gt; ctx.vars.byte
:u8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/ee6f41b76d4dcbe92052946fc6fa70bb38031866/src/codegen.jl#L4-L29">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../parser/">« Parsing buffers</a><a class="docs-footer-nextpage" href="../io/">Parsing IOs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Wednesday 3 July 2024 18:08">Wednesday 3 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
