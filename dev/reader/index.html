<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Creating readers · Automa.jl</title><meta name="title" content="Creating readers · Automa.jl"/><meta property="og:title" content="Creating readers · Automa.jl"/><meta property="twitter:title" content="Creating readers · Automa.jl"/><meta name="description" content="Documentation for Automa.jl."/><meta property="og:description" content="Documentation for Automa.jl."/><meta property="twitter:description" content="Documentation for Automa.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Automa.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../theory/">Theory</a></li><li><a class="tocitem" href="../regex/">Regex</a></li><li><a class="tocitem" href="../validators/">Validators</a></li><li><a class="tocitem" href="../tokenizer/">Tokenizers</a></li><li><a class="tocitem" href="../parser/">Parsing buffers</a></li><li><a class="tocitem" href="../custom/">Customizing codegen</a></li><li><a class="tocitem" href="../io/">Parsing IOs</a></li><li class="is-active"><a class="tocitem" href>Creating readers</a></li><li><a class="tocitem" href="../debugging/">Debugging Automa</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Creating readers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Creating readers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/BioJulia/Automa.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/BioJulia/Automa.jl/blob/master/docs/src/reader.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Creating-a-Reader-type"><a class="docs-heading-anchor" href="#Creating-a-Reader-type">Creating a <code>Reader</code> type</a><a id="Creating-a-Reader-type-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-Reader-type" title="Permalink"></a></h1><p>The use of <code>generate_reader</code> as we learned in the previous section &quot;Parsing from an IO&quot; has an issue we need to address: While we were able to read multiple records from the reader by calling <code>read_record</code> multiple times, no state was preserved between these calls, and so, no state can be preserved between reading individual records. This is also what made it necessary to clumsily reset <code>p</code> after emitting each record.</p><p>Imagine you have a format with two kinds of records, A and B types. A records must come before B records in the file. Hence, while a B record can appear at any time, once you&#39;ve seen a B record, there can&#39;t be any more A records. When reading records from the file, you must be able to store whether you&#39;ve seen a B record.</p><p>We address this by creating a <code>Reader</code> type which wraps the IO being parsed, and which store any state we want to preserve between records. Let&#39;s stick to our <a href="../regex/#fasta_example">simplified FASTA format</a> parsing sequences into <code>Seq</code> objects:</p><pre><code class="language-julia hljs">struct Seq
    name::String
    seq::String
end

machine = let
    header = onexit!(onenter!(re&quot;[a-z]+&quot;, :mark_pos), :header)
    seqline = onexit!(onenter!(re&quot;[ACGT]+&quot;, :mark_pos), :seqline)
    record = onexit!(re&quot;&gt;&quot; * header * &#39;\n&#39; * rep1(seqline * &#39;\n&#39;), :record)
    compile(rep(record))
end
@assert machine isa Automa.Machine</code></pre><p>This time, we use the following <code>Reader</code> type:</p><pre><code class="language-julia hljs">mutable struct Reader{S &lt;: TranscodingStream}
    io::S
    automa_state::Int
end

Reader(io::TranscodingStream) = Reader{typeof(io)}(io, 1)
Reader(io::IO) = Reader(NoopStream(io))</code></pre><p>The <code>Reader</code> contains an instance of <code>TranscodingStream</code> to read from, and stores the Automa state between records. The beginning state of Automa is always 1. We can now create our reader function like below. There are only three differences from the definitions in the previous section:</p><ul><li>I no longer have the code to decrement <code>p</code> in the <code>:record</code> action - because we can store the Automa state between records such that the machine can handle beginning in the middle of a record if necessary, there is no need to reset the value of <code>p</code> in order to restore the IO to the state right before each record.</li><li>I return <code>(cs, state)</code> instead of just <code>state</code>, because I want to update the Automa state of the Reader, so when it reads the next record, it begins in the same state where the machine left off from the previous state</li><li>In the arguments, I add <code>start_state</code>, and in the <code>initcode</code> I set <code>cs</code> to the start state, so the machine begins from the correct state</li></ul><pre><code class="language-julia hljs">actions = Dict{Symbol, Expr}(
    :mark_pos =&gt; :(@mark),
    :header =&gt; :(header = String(data[@markpos():p-1])),
    :seqline =&gt; :(append!(seqbuffer, data[@markpos():p-1])),
    :record =&gt; quote
        seq = Seq(header, String(seqbuffer))
        found_sequence = true
        @escape
    end
)

generate_reader(
    :read_record,
    machine;
    actions=actions,
    arguments=(:(start_state::Int),),
    initcode=quote
        seqbuffer = UInt8[]
        found_sequence = false
        header = &quot;&quot;
        cs = start_state
    end,
    loopcode=quote
        if (is_eof &amp;&amp; p &gt; p_end) || found_sequence
            @goto __return__
        end
    end,
    returncode=:(found_sequence ? (cs, seq) : throw(EOFError()))
) |&gt; eval</code></pre><p>We then create a function that reads from the <code>Reader</code>, making sure to update the <code>automa_state</code> of the reader:</p><pre><code class="language-julia hljs">function read_record(reader::Reader)
    (cs, seq) = read_record(reader.io, reader.automa_state)
    reader.automa_state = cs
    return seq
end</code></pre><p>Let&#39;s test it out:</p><pre><code class="language-julia-repl hljs">julia&gt; reader = Reader(IOBuffer(&quot;&gt;a\nT\n&gt;tag\nGAG\nATATA\n&quot;));

julia&gt; read_record(reader)
Seq(&quot;a&quot;, &quot;T&quot;)

julia&gt; read_record(reader)
Seq(&quot;tag&quot;, &quot;GAGATATA&quot;)

julia&gt; read_record(reader)
ERROR: EOFError: read end of file</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../io/">« Parsing IOs</a><a class="docs-footer-nextpage" href="../debugging/">Debugging Automa »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 15 January 2024 15:27">Monday 15 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
