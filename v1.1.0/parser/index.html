<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parsing buffers · Automa.jl</title><meta name="title" content="Parsing buffers · Automa.jl"/><meta property="og:title" content="Parsing buffers · Automa.jl"/><meta property="twitter:title" content="Parsing buffers · Automa.jl"/><meta name="description" content="Documentation for Automa.jl."/><meta property="og:description" content="Documentation for Automa.jl."/><meta property="twitter:description" content="Documentation for Automa.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Automa.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../theory/">Theory</a></li><li><a class="tocitem" href="../regex/">Regex</a></li><li><a class="tocitem" href="../validators/">Validators</a></li><li><a class="tocitem" href="../tokenizer/">Tokenizers</a></li><li class="is-active"><a class="tocitem" href>Parsing buffers</a><ul class="internal"><li><a class="tocitem" href="#Adding-actions-to-regex"><span>Adding actions to regex</span></a></li><li><a class="tocitem" href="#Compiling-regex-to-Machines"><span>Compiling regex to <code>Machine</code>s</span></a></li><li><a class="tocitem" href="#Creating-our-parser"><span>Creating our parser</span></a></li><li><a class="tocitem" href="#Preconditions"><span>Preconditions</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../custom/">Customizing codegen</a></li><li><a class="tocitem" href="../io/">Parsing IOs</a></li><li><a class="tocitem" href="../reader/">Creating readers</a></li><li><a class="tocitem" href="../debugging/">Debugging Automa</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Parsing buffers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parsing buffers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/BioJulia/Automa.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/BioJulia/Automa.jl/blob/master/docs/src/parser.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Parsing-from-a-buffer"><a class="docs-heading-anchor" href="#Parsing-from-a-buffer">Parsing from a buffer</a><a id="Parsing-from-a-buffer-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing-from-a-buffer" title="Permalink"></a></h1><p>Automa can leverage metaprogramming to combine regex and Julia code to create parsers. This is significantly more difficult than simply using validators or tokenizers, but still simpler than parsing from an IO. Currently, Automa loads data through pointers, and therefore needs data backed by <code>Array{UInt8}</code> or <code>String</code> or similar - it does not work with types such as <code>UnitRange{UInt8}</code>. Furthermore, be careful about passing strided views to Automa - while Automa can extract a pointer from a strided view, it will always advance the pointer one byte at a time, disregarding the view&#39;s stride.</p><p>As an example, let&#39;s use the simplified FASTA format <a href="../regex/#fasta_example">introduced in the regex section</a>, with the following format: <code>re&quot;(&gt;[a-z]+\n([ACGT]+\n)+)*&quot;</code>. We want to parse it into a <code>Vector{Seq}</code>, where <code>Seq</code> is defined as:</p><pre><code class="language-julia-repl hljs">julia&gt; struct Seq
           name::String
           seq::String
       end</code></pre><h2 id="Adding-actions-to-regex"><a class="docs-heading-anchor" href="#Adding-actions-to-regex">Adding actions to regex</a><a id="Adding-actions-to-regex-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-actions-to-regex" title="Permalink"></a></h2><p>To do this, we need to inject Julia code into the regex validator while it is running. The first step is to add <em>actions</em> to our regex: These are simply names of Julia expressions to splice in, where the expressions will be executed when the regex is matched. We can choose the names arbitrarily.</p><p>Currently, actions can be added in the following places in a regex:</p><ul><li>With <code>onenter!</code>, meaning it will be executed when reading the first byte of the regex</li><li>With <code>onfinal!</code>, where it will be executed when reading the last byte of the regex. Note that it&#39;s not possible to determine the final byte for some regex like <code>re&quot;X+&quot;</code>, since the machine reads only 1 byte at a time and cannot look ahead. In such cases, an error is raised.</li><li>With <code>onexit!</code>, meaning it will be executed on reading the first byte AFTER the regex, or when exiting the regex by encountering the end of inputs (only for a regex match, not an unexpected end of input)</li><li>With <code>onall!</code>, where it will be executed when reading every byte that is part of the regex.</li></ul><p>You can set the actions to be a single action name (represented by a <code>Symbol</code>), or a list of action names:</p><pre><code class="language-julia-repl hljs">julia&gt; my_regex = re&quot;ABC&quot;;

julia&gt; onenter!(my_regex, [:action_a, :action_b]);

julia&gt; onexit!(my_regex, :action_c);</code></pre><p>In which case the code named <code>action_a</code>, then that named <code>action_b</code> will executed in order when entering the regex, and the code named <code>action_c</code> will be executed when exiting the regex.</p><p>The <code>onenter!</code> etc functions return the regex they modify, so the above can be written:</p><pre><code class="language-julia-repl hljs">julia&gt; my_regex = onexit!(onenter!(re&quot;ABC&quot;, [:action_a, :action_b]), :action_c);

julia&gt; my_regex isa RE
true</code></pre><p>When the the following regex&#39;s actions are visualized in its corresponding <a href="../theory/#deterministic-finite-automata">DFA</a>:</p><pre><code class="language-julia hljs">regex = let
    ab = re&quot;ab*&quot;
    onenter!(ab, :enter_ab)
    onexit!(ab, :exit_ab)
    onfinal!(ab, :final_ab)
    onall!(ab, :all_ab)
    c = re&quot;c&quot;
    onenter!(c, :enter_c)
    onexit!(c, :exit_c)
    onfinal!(c, :final_c)

    ab * c
end</code></pre><p>The result DFA looks below. Here, the edge labeled <code>&#39;a&#39;/enter_ab,all_ab,final_ab</code> means that the edge consumes input byte <code>&#39;a&#39;</code>, and executes the three actions <code>enter_ab</code>, <code>all_ab</code> and <code>final_ab</code>, in that order. </p><p><img src="../figure/actions.png" alt="Visualization of regex with actions"/></p><h2 id="Compiling-regex-to-Machines"><a class="docs-heading-anchor" href="#Compiling-regex-to-Machines">Compiling regex to <code>Machine</code>s</a><a id="Compiling-regex-to-Machines-1"></a><a class="docs-heading-anchor-permalink" href="#Compiling-regex-to-Machines" title="Permalink"></a></h2><p>In order to create code, the regex must first be compiled to a <code>Machine</code>, which is a struct that represents an optimised DFA. We can do that with <code>compile(regex)</code>. Under the hood, this compiles the regex to an NFA, then compiles the NFA to a DFA, and then optimises the DFA to a <code>Machine</code> (see the section on <a href="../theory/">Automa theory</a>).</p><p>Normally, we don&#39;t care about the regex directly, but only want the <code>Machine</code>. So, it is idiomatic to compile the regex in the same <code>let</code> statement it is being built in:</p><pre><code class="language-julia hljs">machine = let
    header = re&quot;[a-z]+&quot;
    seqline = re&quot;[ACGT]+&quot;
    record = re&quot;&gt;&quot; * header * &#39;\n&#39; * rep1(seqline * &#39;\n&#39;)
    compile(rep(record))
end
@assert machine isa Automa.Machine</code></pre><p>Note that, if this code is placed at top level in a package, the regex will be constructed and compiled to a <code>Machine</code> during package precompilation, which greatly helps load times.</p><h2 id="Creating-our-parser"><a class="docs-heading-anchor" href="#Creating-our-parser">Creating our parser</a><a id="Creating-our-parser-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-our-parser" title="Permalink"></a></h2><p>However, in this case, we don&#39;t just need a <code>Machine</code> with the regex, we need a <code>Machine</code> with the regex <em>containing the relevant actions</em>. To parse a simplified FASTA file into a <code>Vector{Seq}</code>, I&#39;m using these four actions:</p><ul><li>When the machine enters into the header, or a sequence line, I want it to mark the position with where it entered into the regex. The marked position will be used as the leftmost position where the header or sequence is extracted later.</li><li>When exiting the header, I want to extract the bytes from the marked position in the action above, to the last header byte (i.e. the byte before the current byte), and use these bytes as the sequence header</li><li>When exiting a sequence line, I want to do the same: Extract from the marked position to one before the current position, but this time I want to append the current line to a buffer containing all the lines of the sequence</li><li>When exiting a record, I want to construct a <code>Seq</code> object from the header bytes and the buffer with all the sequence lines, then push the <code>Seq</code> to the result,</li></ul><pre><code class="language-julia-repl hljs">julia&gt; machine = let
           header = onexit!(onenter!(re&quot;[a-z]+&quot;, :mark_pos), :header)
           seqline = onexit!(onenter!(re&quot;[ACGT]+&quot;, :mark_pos), :seqline)
           record = onexit!(re&quot;&gt;&quot; * header * &#39;\n&#39; * rep1(seqline * &#39;\n&#39;), :record)
           compile(rep(record))
       end;</code></pre><p>We can now write the code we want executed. When writing this code, we want access to a few variables used by the machine simulation. For example, we might want to know at which byte position the machine is when an action is executed. Currently, the following variables are accessible in the code:</p><ul><li><code>byte</code>: The current input byte as a <code>UInt8</code></li><li><code>p</code>: The 1-indexed position of <code>byte</code> in the buffer</li><li><code>p_end</code>: The length of the input buffer</li><li><code>is_eof</code>: Whether the machine has reached the end of the input.</li><li><code>cs</code>: The current state of the machine, as an integer</li><li><code>data</code>: The input buffer</li><li><code>mem</code>: The memory being read from, an <code>Automa.SizedMemory</code> object containing a pointer and a length</li></ul><p>The actions we want executed, we place in a <code>Dict{Symbol, Expr}</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; actions = Dict(
           :mark_pos =&gt; :(pos = p),
           :header =&gt; :(header = String(data[pos:p-1])),
           :seqline =&gt; :(append!(buffer, data[pos:p-1])),
           :record =&gt; :(push!(seqs, Seq(header, String(buffer))))
       );</code></pre><p>For multi-line <code>Expr</code>, you can construct them with <code>quote ... end</code> blocks.</p><p>We can now construct a function that parses our data. In the code written in the action dict above, besides the variables defined for us by Automa, we also refer to the variables <code>buffer</code>, <code>header</code>, <code>pos</code> and <code>seqs</code>. Some of these variables are defined in the code above (for example, in the <code>:(pos = p)</code> expression), but we can&#39;t necessarily control the order in which Automa will insert these expressions into out final function. Hence, let&#39;s initialize these variables at the top of the function we generate, such that we know for sure they are defined when used - whenever they are used.</p><p>The code itself is generated using <code>generate_code</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @eval function parse_fasta(data)
           pos = 0
           buffer = UInt8[]
           seqs = Seq[]
           header = &quot;&quot;
           $(generate_code(machine, actions))
           return seqs
       end
parse_fasta (generic function with 1 method)</code></pre><p>We can now use it:</p><pre><code class="language-julia-repl hljs">julia&gt; parse_fasta(&quot;&gt;abc\nTAGA\nAAGA\n&gt;header\nAAAG\nGGCG\n&quot;)
2-element Vector{Seq}:
 Seq(&quot;abc&quot;, &quot;TAGAAAGA&quot;)
 Seq(&quot;header&quot;, &quot;AAAGGGCG&quot;)</code></pre><p>If we give out function a bad input - for example, if we forget the trailing newline, it throws an error:</p><pre><code class="language-julia-repl hljs">julia&gt; parse_fasta(&quot;&gt;abc\nTAGA\nAAGA\n&gt;header\nAAAG\nGGCG&quot;)
ERROR: Error during FSM execution at buffer position 33.
Last 32 byte(s) were:

&quot;&gt;abc\nTAGA\nAAGA\n&gt;header\nAAAG\nGGCG&quot;

Observed input: EOF at state 5. Outgoing edges:
 * &#39;\n&#39;/seqline
 * [ACGT]

Input is not in any outgoing edge, and machine therefore errored.</code></pre><p>The code above parses with about 300 MB/s on my laptop. Not bad, but Automa can do better - read on to learn how to customize codegen.</p><h2 id="Preconditions"><a class="docs-heading-anchor" href="#Preconditions">Preconditions</a><a id="Preconditions-1"></a><a class="docs-heading-anchor-permalink" href="#Preconditions" title="Permalink"></a></h2><p>You might have noticed a peculiar detail about our FASTA format: It demands a trailing newline after each record. In other words, <code>&gt;a\nA</code> is not a valid FASTA record.</p><p>We can easily rewrite the regex such that the last record does not need a trailing <code>\n</code>. But look what happens when we try that:</p><pre><code class="language-julia-repl hljs">julia&gt; machine = let
           header = onexit!(onenter!(re&quot;[a-z]+&quot;, :mark_pos), :header)
           seqline = onexit!(onenter!(re&quot;[ACGT]+&quot;, :mark_pos), :seqline)
           record = onexit!(re&quot;&gt;&quot; * header * &#39;\n&#39; * seqline * rep(&#39;\n&#39; * seqline), :record)
           compile(opt(record) * rep(&#39;\n&#39; * record) * rep(re&quot;\n&quot;))
       end;
ERROR: Ambiguous NFA.</code></pre><p>Why does this error? Well, remember that Automa processes one byte at a time, and at each byte, makes a decision on what actions to execute. Hence, if it sees the input <code>&gt;a\nA\n</code>, it does not know what to do when encountering the second <code>\n</code>. If the next byte is, e,g. <code>A</code>, then it would need to execute the <code>:seqline</code> action. If the byte is <code>&gt;</code>, it would need to execute first <code>:seqline</code>, then <code>:record</code>. Automa can&#39;t read ahead, so, the regex is ambiguous and the true behaviour when reading the inputs <code>&gt;a\nA\n</code> is undefined. Therefore, Automa refuses to compile it.</p><p>There are several ways to solve this:</p><ul><li>First, you can rewrite the regex to not be ambiguous. This is usually the preferred option: After all, if the regex is ambiguous, you probably made a mistake with the regex</li><li>You can manually diasable the ambiguity check by passing the keyword <code>unambiguous=false</code> to <code>compile</code>. This will cause the machine to undefined behaviour if an input like <code>&gt;a\nA\n</code> is seen, so this is usually a poor idea.</li><li>You can rewrite the actions, such that the action itself uses an if-statement to check what to do. In the example above, you could remove the <code>:record</code> action and have the <code>:seqline</code> action conditionally emit a record if the next byte was <code>&gt;</code>.</li></ul><p>Finally, you can use <em>preconditions</em>. A precondition is a symbol, attached to a regex, just like an action. Just like an action, the symbol is attached to an <code>Expr</code> object, but for preconditions this must evaluate to a <code>Bool</code>. If <code>false</code>, the regex is not entered.</p><p>Let&#39;s have an example. The following machine is obviously ambiguous:</p><pre><code class="language-julia-repl hljs">julia&gt; machine = let
           a = onenter!(re&quot;XY&quot;, :a)
           b = onenter!(re&quot;XZ&quot;, :b)
           compile(&#39;A&#39; * (a | b))
       end;
ERROR: Ambiguous NFA.</code></pre><p>We can add a precondition with <code>precond!</code>. Below, <code>precond!(regex, label)</code> is equivalent to <code>precond!(regex, label; when=:enter, bool=true)</code>. This means &quot;only enter <code>regex</code> when the boolean expression <code>label</code> evaluates to <code>bool</code> (<code>true</code>)&quot;:</p><pre><code class="language-julia-repl hljs">julia&gt; machine = let
           a = precond!(onenter!(re&quot;XY&quot;, :a), :test)
           b = precond!(onenter!(re&quot;XZ&quot;, :b), :test; bool=false)
           compile(&#39;A&#39; * (a | b))
       end;

julia&gt; machine isa Automa.Machine
true</code></pre><p>Here, <code>re&quot;XY&quot;</code> can only be entered when <code>:test</code> is <code>true</code>, and <code>re&quot;XZ&quot;</code> only when <code>:test</code> is <code>false</code>. So, there can be no ambiguous behaviour and the regex compiles fine.</p><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.RegExp.onenter!" href="#Automa.RegExp.onenter!"><code>Automa.RegExp.onenter!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">onenter!(re::RE, a::Union{Symbol, Vector{Symbol}}) -&gt; re</code></pre><p>Set action(s) <code>a</code> to occur when reading the first byte of regex <code>re</code>. If multiple actions are set by passing a vector, execute the actions in order.</p><p>See also: <a href="#Automa.RegExp.onexit!"><code>onexit!</code></a>, <a href="#Automa.RegExp.onall!"><code>onall!</code></a>, <a href="#Automa.RegExp.onfinal!"><code>onfinal!</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; regex = re&quot;ab?c*&quot;;

julia&gt; regex2 = onenter!(regex, :entering_regex);

julia&gt; regex === regex2
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/b08d53b7940af2b81c780f50a98205a0a4e60cf6/src/re.jl#L67-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.RegExp.onexit!" href="#Automa.RegExp.onexit!"><code>Automa.RegExp.onexit!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">onexit!(re::RE, a::Union{Symbol, Vector{Symbol}}) -&gt; re</code></pre><p>Set action(s) <code>a</code> to occur when reading the first byte no longer part of regex <code>re</code>, or if experiencing an expected end-of-file. If multiple actions are set by passing a vector, execute the actions in order.</p><p>See also: <a href="#Automa.RegExp.onenter!"><code>onenter!</code></a>, <a href="#Automa.RegExp.onall!"><code>onall!</code></a>, <a href="#Automa.RegExp.onfinal!"><code>onfinal!</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; regex = re&quot;ab?c*&quot;;

julia&gt; regex2 = onexit!(regex, :exiting_regex);

julia&gt; regex === regex2
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/b08d53b7940af2b81c780f50a98205a0a4e60cf6/src/re.jl#L88-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.RegExp.onall!" href="#Automa.RegExp.onall!"><code>Automa.RegExp.onall!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">onall!(re::RE, a::Union{Symbol, Vector{Symbol}}) -&gt; re</code></pre><p>Set action(s) <code>a</code> to occur when reading any byte part of the regex <code>re</code>. If multiple actions are set by passing a vector, execute the actions in order.</p><p>See also: <a href="#Automa.RegExp.onenter!"><code>onenter!</code></a>, <a href="#Automa.RegExp.onexit!"><code>onexit!</code></a>, <a href="#Automa.RegExp.onfinal!"><code>onfinal!</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; regex = re&quot;ab?c*&quot;;

julia&gt; regex2 = onall!(regex, :reading_re_byte);

julia&gt; regex === regex2
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/b08d53b7940af2b81c780f50a98205a0a4e60cf6/src/re.jl#L136-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.RegExp.onfinal!" href="#Automa.RegExp.onfinal!"><code>Automa.RegExp.onfinal!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">onfinal!(re::RE, a::Union{Symbol, Vector{Symbol}}) -&gt; re</code></pre><p>Set action(s) <code>a</code> to occur when the last byte of regex <code>re</code>. If <code>re</code> does not have a definite final byte, e.g. <code>re&quot;a(bc)*&quot;</code>, where more &quot;bc&quot; can always be added, compiling the regex will error after setting a final action. If multiple actions are set by passing a vector, execute the actions in order.</p><p>See also: <a href="#Automa.RegExp.onenter!"><code>onenter!</code></a>, <a href="#Automa.RegExp.onall!"><code>onall!</code></a>, <a href="#Automa.RegExp.onexit!"><code>onexit!</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; regex = re&quot;ab?c&quot;;

julia&gt; regex2 = onfinal!(regex, :entering_last_byte);

julia&gt; regex === regex2
true

julia&gt; compile(onfinal!(re&quot;ab?c*&quot;, :does_not_work))
ERROR: [...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/b08d53b7940af2b81c780f50a98205a0a4e60cf6/src/re.jl#L110-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.RegExp.precond!" href="#Automa.RegExp.precond!"><code>Automa.RegExp.precond!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">precond!(re::RE, s::Symbol; [when=:enter], [bool=true]) -&gt; re</code></pre><p>Set <code>re</code>&#39;s precondition to <code>s</code>. Before any state transitions to <code>re</code>, or inside <code>re</code>, the precondition code <code>s</code> is checked to be <code>bool</code> before the transition is taken.</p><p><code>when</code> controls if the condition is checked when the regex is entered (if <code>:enter</code>), or at every state transition inside the regex (if <code>:all</code>)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; regex = re&quot;ab?c*&quot;;

julia&gt; regex2 = precond!(regex, :some_condition);

julia&gt; regex === regex2
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/b08d53b7940af2b81c780f50a98205a0a4e60cf6/src/re.jl#L157-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.generate_code" href="#Automa.generate_code"><code>Automa.generate_code</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_code([::CodeGenContext], machine::Machine, actions=nothing)::Expr</code></pre><p>Generate init and exec code for <code>machine</code>. The default code generator function for creating functions, preferentially use this over generating init and exec code directly, due to its convenience.  Shorthand for producing the concatenated code of:</p><ul><li><code>generate_init_code(ctx, machine)</code></li><li><code>generate_action_code(ctx, machine, actions)</code></li><li><code>generate_input_error_code(ctx, machine)</code> [elided if actions == :debug]</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">@eval function foo(data)
    # Initialize variables used in actions
    data_buffer = UInt8[]
    $(generate_code(machine, actions))
    return data_buffer
end</code></pre><p>See also: <a href="#Automa.generate_init_code"><code>generate_init_code</code></a>, <a href="#Automa.generate_exec_code"><code>generate_exec_code</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/b08d53b7940af2b81c780f50a98205a0a4e60cf6/src/codegen.jl#L167-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.generate_init_code" href="#Automa.generate_init_code"><code>Automa.generate_init_code</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_init_code([::CodeGenContext], machine::Machine)::Expr</code></pre><p>Generate variable initialization code, initializing variables such as <code>p</code>, and <code>p_end</code>. The names of these variables are set by the <code>CodeGenContext</code>. If not passed, the context defaults to <code>DefaultCodeGenContext</code></p><p>Prefer using the more generic <code>generate_code</code> over this function where possible. This function should be used if the initialized data should be modified before the execution code.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">@eval function foo(data)
    $(generate_init_code(machine))
    p = 2 # maybe I want to start from position 2, not 1
    $(generate_exec_code(machine, actions))
    return cs
end</code></pre><p>See also: <a href="#Automa.generate_code"><code>generate_code</code></a>, <a href="#Automa.generate_exec_code"><code>generate_exec_code</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/b08d53b7940af2b81c780f50a98205a0a4e60cf6/src/codegen.jl#L210-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Automa.generate_exec_code" href="#Automa.generate_exec_code"><code>Automa.generate_exec_code</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_exec_code([::CodeGenContext], machine::Machine, actions=nothing)::Expr</code></pre><p>Generate machine execution code with actions. This code should be run after the machine has been initialized with <code>generate_init_code</code>. If not passed, the context defaults to <code>DefaultCodeGenContext</code></p><p>Prefer using the more generic <code>generate_code</code> over this function where possible. This function should be used if the initialized data should be modified before the execution code.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">@eval function foo(data)
    $(generate_init_code(machine))
    p = 2 # maybe I want to start from position 2, not 1
    $(generate_exec_code(machine, actions))
    return cs
end</code></pre><p>See also: <a href="#Automa.generate_init_code"><code>generate_init_code</code></a>, <a href="#Automa.generate_exec_code"><code>generate_exec_code</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BioJulia/Automa.jl/blob/b08d53b7940af2b81c780f50a98205a0a4e60cf6/src/codegen.jl#L249-L271">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tokenizer/">« Tokenizers</a><a class="docs-footer-nextpage" href="../custom/">Customizing codegen »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 18 October 2024 15:52">Friday 18 October 2024</span>. Using Julia version 1.11.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
